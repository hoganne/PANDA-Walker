# red—back—tree红黑树

## 红黑树

红黑树，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉查找树(BST)，树上的每个节点都遵循下面的规则:

1. 每个节点都有红色或黑色
2. 树的根始终是黑色的 (黑土地孕育黑树根， )
3. 没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，**并没有说不能出现连续的黑色节点**）
4. 从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点

瞬间懵逼？**了解一下印象就行**，开始玩魔方都是要照着魔方公式一点点玩的，多玩几次就熟悉了。红黑树也一样，红黑树有两大操作:

1. recolor (重新标记黑色或红色)
2. rotation (旋转，这是树达到平衡的关键)

我们会先尝试 recolor，如果 recolor 不能达到红黑树的 4 点要求，然后我们尝试 rotation，其实红黑树的关键玩法就是弄清楚 recolor 和 rotation 的规则，接下来看看详细的算法公式吧 **千万别着急记忆公式，有图示会逐步说明，就像魔方一样，多玩几次就懂了**:
假设我们插入的新节点为 X

1. 将新插入的节点标记为红色

2. 如果 X 是根结点(root)，则标记为黑色

3. 如果 X 的 parent 不是黑色，同时 X 也不是 root:

   3.1 如果 X 的 uncle (叔叔) 是红色

- - 3.1.1 将 parent 和 uncle 标记为黑色
  - 3.1.2 将 grand parent (祖父) 标记为红色
  - 3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3

话不多说，看下图

![img](https://pic4.zhimg.com/80/v2-1d35b926316397d82c267593042f8c3f_720w.jpg)

跟着上面的公式走:

1. 将新插入的 X 节点标记为红色
2. 发现 X 的 parent (P) 同样为红色，这违反了红黑树的第三条规则「不能有两个连续相邻的红色节点」
3. 发现 X 的 uncle (U) 同样为红色
4. 将 P 和 U 标记为黑色
5. 将 X 和 X 的 grand parent (G) 标记为相同的颜色，即红色，继续重复公式 2、3
6. 发现 G 是根结点，标记为黑色
7. 结束

刚刚说了` X` 的 uncle 是红色的情况，接下来要说是黑色的情况

1. 如果 X 的 parent 不是黑色，同时 X 也不是 root:

- 3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理

- - 3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子)
  - 3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子)
  - 3.2.3 右右 (和 3.2.1 镜像过来，恰好相反)
  - 3.2.4 右左 (和 3.2.2 镜像过来，恰好相反)

当出现 uncle 是黑色的时候我们第一步要考虑的是 **旋转** ，这里先请小伙伴**不要关注红黑树的第 4 条规则**，主要是为了演示如何旋转的，来一点点看，不要看图就慌，有解释的 :

### 左左情况

这种情况很简单，想象这是一根绳子，手提起 P 节点，然后变色即可

![img](https://pic1.zhimg.com/80/v2-9e139a0f8b4a5e00ca8e643e2130403c_720w.jpg)

### 左右

左旋: 使 X 的父节点 P 被 X 取代，同时父节点 P 成为 X 的左孩子，然后再应用 **左左情况**

![img](https://pic4.zhimg.com/80/v2-3fb33fbb3a42e34ed8a058a047a44cc3_720w.jpg)

### 右右

与左左情况一样，想象成一根绳子

![img](https://pic4.zhimg.com/80/v2-62a42ada09cb4547191aa4b9051c7c23_720w.jpg)

### 右左

右旋: 使 X 的父节点 P 被 X 取代，同时父节点 P 成为 X 的右孩子，然后再应用 **右右情况**

![img](https://pic4.zhimg.com/80/v2-210d1400ea1b098dfe1582589a6064c3_720w.jpg)

## 演示网址：https://rbtree.phpisfuture.com/



# 红黑树与AVL树讲解二

红黑树简介红黑树是一种自平衡的二叉查找树，是一种高效的查找树。它是由 Rudolf Bayer 于1972年发明，在当时被称为对称二叉 B 树(symmetric binary B-trees)。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的红黑树。红黑树具有良好的效率，它可在 O(logN) 时间内完成查找、增加、删除等操作。因此，红黑树在业界应用很广泛，比如 Java 中的 TreeMap，JDK 1.8 中的 HashMap、C++ STL 中的 map 均是基于红黑树结构实现的。考虑到红黑树是一种被广泛应用的数据结构，所以我们很有必要去弄懂它。
![img](https://pic1.zhimg.com/v2-39965fba3e7e0ceea2deba09a0446348_b.jpg)
红黑树的性质学过二叉查找树的同学都知道，普通的二叉查找树在极端情况下可退化成链表，此时的增删查效率都会比较低下。为了避免这种情况，就出现了一些自平衡的查找树，比如 AVL，红黑树等。这些自平衡的查找树通过定义一些性质，将任意节点的左右子树高度差控制在规定范围内，以达到平衡状态。以红黑树为例，红黑树通过如下的性质定义实现自平衡：节点是红色或黑色。
根是黑色。
所有叶子都是黑色（叶子是NIL节点）。
每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。有了上面的几个性质作为限制，即可避免二叉查找树退化成单链表的情况。但是，仅仅避免这种情况还不够，这里还要考虑某个节点到其每个叶子节点路径长度的问题。如果某些路径长度过长，那么，在对这些路径上的及诶单进行增删查操作时，效率也会大大降低。这个时候性质4和性质5用途就凸显了，有了这两个性质作为约束，即可保证任意节点到其每个叶子节点路径最长不会超过最短路径的2倍。原因如下：当某条路径最短时，这条路径必然都是由黑色节点构成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成（性质4限定了不能出现两个连续的红色节点）。而性质5又限定了从任一节点到其每个叶子节点的所有路径必须包含相同数量的黑色节点。此时，在路径最长的情况下，路径上红色节点数量 = 黑色节点数量。该路径长度为两倍黑色节点数量，也就是最短路径长度的2倍。举例说明一下，请看下图：
![img](https://pic1.zhimg.com/v2-c5ec8ec8eb6441873cd900e03837c5bc_b.jpg)
上图画出了从根节点 M 出发的到其叶子节点的最长和最短路径。这里偷懒只画出了两条最长路径，实际上最长路径有4条，分别为：M -> Q -> O -> NM -> Q -> O -> pM -> Q -> Y -> XM -> Q -> Y -> Z长度为4，最短路径为 M -> E，长度为2。最长路径的长度正好为最短路径长度的2倍。前面说了关于红黑树的一些性质，这里还需要补充一些其他方面的东西。在红黑树简介一节中说到红黑树被发明出来的时候并不叫红黑树，而是叫做对称二叉 B 树，从名字中可发现红黑树和 B 树（这里指的是2-3树）或许有一定的关联，事实也正是如此。如果对红黑树的性质稍加修改，就能让红黑树和B树形成一一对应的关系。关于红黑树和 B 树关系的细节这里不展开说明了，有兴趣的同学可以参考《算法》第4版，那本书上讲的很透彻。红黑树操作红黑树的基本操作和其他树形结构一样，一般都包括查找、插入、删除等操作。前面说到，红黑树是一种自平衡的二叉查找树，既然是二叉查找树的一种，那么查找过程和二叉查找树一样，比较简单，这里不再赘述。相对于查找操作，红黑树的插入和删除操作就要复杂的多。尤其是删除操作，要处理的情况比较多，不过大家如果静下心来去看，会发现其实也没想的那么难。好了，废话就说到这，接下来步入正题吧。旋转操作在分析插入和删除操作前，这里需要插个队，先说明一下旋转操作，这个操作在后续操作中都会用得到。旋转操作分为左旋和右旋，左旋是将某个节点旋转为其右孩子的左孩子，而右旋是节点旋转为其左孩子的右孩子。这话听起来有点绕，所以还是请看下图：
![img](https://pic1.zhimg.com/v2-75bdfdabdc54aef5c0fd07e33e340d74_b.jpg)
上图包含了左旋和右旋的示意图，这里以右旋为例进行说明，右旋节点 M 的步骤如下：将节点 M 的左孩子引用指向节点 E 的右孩子将节点 E 的右孩子引用指向节点 M，完成旋转
![img](https://pic1.zhimg.com/v2-6a1fdb1dc9fe11c6fb8910daa1886534_b.jpg)
上面分析了右旋操作，左旋操作与此类似，大家有兴趣自己画图试试吧，这里不再赘述了。旋转操作本身并不复杂，这里先分析到这吧。插入红黑树的插入过程和二叉查找树插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要进行调整，以满足红黑树的性质。性质1规定红黑树节点的颜色要么是红色要么是黑色，那么在插入新节点时，这个节点应该是红色还是黑色呢？答案是红色，原因也不难理解。如果插入的节点是黑色，那么这个节点所在路径比其他路径多出一个黑色节点，这个调整起来会比较麻烦（参考红黑树的删除操作，就知道为啥多一个或少一个黑色节点时，调整起来这么麻烦了）。如果插入的节点是红色，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转进行调整即可，比之前的简单多了。接下来，将分析插入红色节点后红黑树的情况。这里假设要插入的节点为 N，N 的父节点为 P，祖父节点为 G，叔叔节点为 U。插入红色节点后，会出现5种情况，分别如下：**情况一：**插入的新节点 N 是红黑树的根节点，这种情况下，我们把节点 N 的颜色由红色变为黑色，性质2（根是黑色）被满足。同时 N 被染成黑色后，红黑树所有路径上的黑色节点数量增加一个，性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点）仍然被满足。
![img](https://pic2.zhimg.com/v2-02ba6d02bffc15948e04c6aa6f716605_b.jpg)
**情况二：**N 的父节点是黑色，这种情况下，性质4（每个红色节点必须有两个黑色的子节点）和性质5没有受到影响，不需要调整。
![img](https://pic2.zhimg.com/v2-201853b1fbb411081b74bd93ad133641_b.jpg)
**情况三：**N 的父节点是红色（节点 P 为红色，其父节点必然为黑色），叔叔节点 U 也是红色。由于 P 和 N 均为红色，所有性质4被打破，此时需要进行调整。这种情况下，先将 P 和 U 的颜色染成黑色，再将 G 的颜色染成红色。此时经过 G 的路径上的黑色节点数量不变，性质5仍然满足。但需要注意的是 G 被染成红色后，可能会和它的父节点形成连续的红色节点，此时需要递归向上调整。
![img](https://pic3.zhimg.com/v2-5be69b528010012fee19f0bf86193eb2_b.jpg)
**情况四：**N 的父节点为红色，叔叔节点为黑色。节点 N 是 P 的右孩子，且节点 P 是 G 的左孩子。此时先对节点 P 进行左旋，调整 N 与 P 的位置。接下来按照情况五进行处理，以恢复性质4。
![img](https://pic2.zhimg.com/v2-9f9247d41e7648cc8d0947e3da642a29_b.jpg)
这里需要特别说明一下，上图中的节点 N 并非是新插入的节点。当 P 为红色时，P 有两个孩子节点，且孩子节点均为黑色，这样从 G 出发到各叶子节点路径上的黑色节点数量才能保持一致。既然 P 已经有两个孩子了，所以 N 不是新插入的节点。情况四是由以 N 为根节点的子树中插入了新节点，经过调整后，导致 N 被变为红色，进而导致了情况四的出现。考虑下面这种情况（PR 节点就是上图的 N 节点）：

![img](https://pic3.zhimg.com/v2-e1d6fe954a2ba866ce351ed9d437e0ce_b.jpg)
如上图，插入节点 N 并按情况三处理。此时 PR 被染成了红色，与 P 节点形成了连续的红色节点，这个时候就需按情况四再次进行调整。**情况五：**N 的父节点为红色，叔叔节点为黑色。N 是 P 的左孩子，且节点 P 是 G 的左孩子。此时对 G 进行右旋，调整 P 和 G 的位置，并互换颜色。经过这样的调整后，性质4被恢复，同时也未破坏性质5。
![img](https://pic2.zhimg.com/v2-dd3f7f7873967f9693d3ec5a81fdd739_b.jpg)
插入总结上面五种情况中，情况一和情况二比较简单，情况三、四、五稍复杂。但如果细心观察，会发现这三种情况的区别在于叔叔节点的颜色，如果叔叔节点为红色，直接变色即可。如果叔叔节点为黑色，则需要选选择，再交换颜色。当把这三种情况的图画在一起就区别就比较容易观察了，如下图：
![img](https://pic3.zhimg.com/v2-36af4bd9f695551261f547c27ffce862_b.jpg)
删除相较于插入操作，红黑树的删除操作则要更为复杂一些。删除操作首先要确定待删除节点有几个孩子，如果有两个孩子，不能直接删除该节点。而是要先找到该节点的前驱（该节点左子树中最大的节点）或者后继（该节点右子树中最小的节点），然后将前驱或者后继的值复制到要删除的节点中，最后再将前驱或后继删除。由于前驱和后继至多只有一个孩子节点，这样我们就把原来要删除的节点有两个孩子的问题转化为只有一个孩子节点的问题，问题被简化了一些。我们并不关心最终被删除的节点是否是我们开始想要删除的那个节点，只要节点里的值最终被删除就行了，至于树结构如何变化，这个并不重要。红黑树删除操作的复杂度在于删除节点的颜色，当删除的节点是红色时，直接拿其孩子节点补空位即可。因为删除红色节点，性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点）仍能够被满足。当删除的节点是黑色时，那么所有经过该节点的路径上的黑节点数量少了一个，破坏了性质5。如果该节点的孩子为红色，直接拿孩子节点替换被删除的节点，并将孩子节点染成黑色，即可恢复性质5。但如果孩子节点为黑色，处理起来就要复杂的多。分为6种情况，下面会展开说明。在展开说明之前，我们先做一些假设，方便说明。这里假设最终被删除的节点为X（至多只有一个孩子节点），其孩子节点为N，X的兄弟节点为S，S的左节点为 SL，右节点为 SR。接下来讨论是建立在节点 X 被删除，节点 N 替换X的基础上进行的。这里说明把被删除的节点X特地拎出来说一下的原因是防止大家误以为节点N会被删除，不然后面就会看不明白。
![img](https://pic3.zhimg.com/v2-c7c83ee8be475f338179604a74bb3f86_b.jpg)
在上面的基础上，接下来就可以展开讨论了。红黑树删除有6种情况，分别是：**情况一：**N 是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。上面是维基百科中关于红黑树删除的情况一说明，由于没有配图，看的有点晕。经过思考，我觉得可能会是下面这种情形：要删除的节点 X 是根节点，且左右孩子节点均为空节点，此时将节点 X 用空节点替换完成删除操作。可能还有其他情形，大家如果知道，烦请告知。**情况二：**S 为红色，其他节点为黑色。这种情况下可以对 N 的父节点进行左旋操作，然后互换 P 与 S 颜色。但这并未结束，经过节点 P 和 N 的路径删除前有3个黑色节点（P -> X -> N），现在只剩两个了（P -> N）。比未经过 N 的路径少一个黑色节点，性质5仍不满足，还需要继续调整。不过此时可以按照情况四、五、六进行调整。
![img](https://pic4.zhimg.com/v2-6f7fd7d7f594e3b231c526aa11a219eb_b.jpg)
**情况三：**N 的父节点，兄弟节点 S 和 S 的孩子节点均为黑色。这种情况下可以简单的把 S 染成红色，所有经过 S 的路径比之前少了一个黑色节点，这样经过 N 的路径和经过 S 的路径黑色节点数量一致了。但经过 P 的路径比不经过 P 的路径少一个黑色节点，此时需要从情况一开始对 P 进行平衡处理。
![img](https://pic3.zhimg.com/v2-f1cb182ae6c6ceba9c71c282e05c20c2_b.jpg)
**情况四：**N 的父节点是红色，S 和 S 孩子为黑色。这种情况比较简单，我们只需交换 P 和 S 颜色即可。这样所有通过 N 的路径上增加了一个黑色节点，所有通过 S 的节点的路径必然也通过 P 节点，由于 P 与 S 只是互换颜色，并不影响这些路径。
![img](https://pic1.zhimg.com/v2-fccb3b9e2d270d15375754798bf9dfd4_b.jpg)
这里需要特别说明一下，上图中的节点 N 并非是新插入的节点。当 P 为红色时，P 有两个孩子节点，且孩子节点均为黑色，这样从 G 出发到各叶子节点路径上的黑色节点数量才能保持一致。既然 P 已经有两个孩子了，所以 N 不是新插入的节点。情况四是由以 N 为根节点的子树中插入了新节点，经过调整后，导致 N 被变为红色，进而导致了情况四的出现。考虑下面这种情况（PR 节点就是上图的 N 节点）：
![img](https://pic2.zhimg.com/v2-0f118be1b049211a94689c9006ce3dd5_b.jpg)
**情况五：**S 为黑色，S 的左孩子为红色，右孩子为黑色。N 的父节点颜色可红可黑，且 N 是 P 左孩子。这种情况下对 S 进行右旋操作，并互换 S 和 SL 的颜色。此时，所有路径上的黑色数量仍然相等，N 兄弟节点的由 S 变为了 SL，而 SL 的右孩子变为红色。接下来我们到情况六继续分析。
![img](https://pic4.zhimg.com/v2-41ab641f65f699ef03cfdd18970eac2f_b.jpg)
**情况六：**S 为黑色，S 的右孩子为红色。N 的父节点颜色可红可黑，且 N 是其父节点左孩子。这种情况下，我们对 P 进行左旋操作，并互换 P 和 S 的颜色，并将 SR 变为黑色。因为 P 变为黑色，所以经过 N 的路径多了一个黑色节点，经过 N 的路径上的黑色节点与删除前的数量一致。对于不经过 N 的路径，则有以下两种情况：该路径经过 N 新的兄弟节点 SL ，那它之前必然经过 S 和 P。而 S 和 P 现在只是交换颜色，对于经过 SL 的路径不影响。该路径经过 N 新的叔叔节点 SR，那它之前必然经过 P、 S 和 SR，而现在它只经过 S 和 SR。在对 P 进行左旋，并与 S 换色后，经过 SR 的路径少了一个黑色节点，性质5被打破。另外，由于 S 的颜色可红可黑，如果 S 是红色的话，会与 SR 形成连续的红色节点，打破性质4（每个红色节点必须有两个黑色的子节点）。此时仅需将 SR 由红色变为黑色即可同时恢复性质4和性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。）。
![img](https://pic4.zhimg.com/v2-b8b8b84890d17764f209b676eda04dff_b.jpg)
删除总结红黑树删除的情况比较多，大家刚开始看的时候可能会比较晕。可能会产生这样的疑问，为啥红黑树会有这种删除情况，为啥又会有另一种情况，它们之间有什么联系和区别？和大家一样，我刚开始看的时候也有这样的困惑，直到我把所有情况对应的图形画在一起时，拨云见日，一切都明了了。此时天空中出现了4个字，原来如此、原来如此、原来如此。所以，请看图吧：
![img](https://pic4.zhimg.com/v2-70fc7a9e4f92536e8e192b182d6b1a07_b.jpg)

## [*红黑树*插入、删除、实现与绘制（一）](https://zhuanlan.zhihu.com/p/262483887)

**mathnull**：生成1000颗*红黑树*，并在树上随机删除节点。本位分为三部分：*红黑树*的插入；*红黑树*的删除；*红黑树*实现、测试和可视化。代码实...阅读全文

赞同 7添加评论2020-10-23

## [我画了 20 张图，给女朋友讲清楚*红黑树*](https://zhuanlan.zhihu.com/p/95892351)

[![程序员吴师兄](https://pic4.zhimg.com/50/v2-101f6873d57dcb447157800d8cc33023_s.jpg?source=4e949a73)](https://www.zhihu.com/people/cxyxiaowu)

[程序员吴师兄](https://www.zhihu.com/people/cxyxiaowu)

公众号：五分钟学算法，专注分享算法知识！

作者：CJW红黑树是一种常见的自平衡二叉查找树，常用于关联数组、字典，在各种语言的底层实现中被广泛应用，Java的TreeMap和TreeSet就是基于红黑树实现的。本篇分享将为读者讲解红黑树的定义、创建和用途。一.红黑树的定义每个节点或者是黑色，或者是红色。根节点是黑色。每个叶子节点是黑色。如果一个节点是红色的，则它的子节点必须是黑色的从任意一个节点到叶子节点，经过的黑色节点是一样的。这段关于 *红黑树* 的描述来源于 **《算法导论》**，你看完这段话可能一脸懵逼。本文希望能够由浅入深地、渐进式地引导读者了解红黑树，因此我们会先从红黑树的意义说起，为什么我们需要一棵红黑树。二. 平衡二叉查找树我们以这样一个数组为例 [42，37，18，12，11，6，5] 构建一棵二叉搜索树，由于数组中任意一点都可以作为二叉搜索树的根节点，因此这棵二叉搜索树并不唯一，我们来看一个极端的例子（以42作为根节点，顺序插入元素）
![img](https://pic3.zhimg.com/v2-1638a7c8e351f33ccf2b7ae2a6a7d566_b.jpg)
在这个例子中，二叉搜索树退化成了链表，搜索的时间复杂度为 O(n)，失去了作为一棵二叉搜索树的意义。为了让二叉搜索树不至于太“倾斜”，我们需要构建一棵 **平衡二叉搜索树**。
![img](https://pic1.zhimg.com/v2-bf875620d5d43b5c35a7939a2c013784_b.jpg)
可以看出，平衡二叉搜索树的搜索时间复杂度为O(logn)，避免了因为随机选取根节点构建二叉搜索树而可能造成的退化成链表的情况。下面再抄一段平衡二叉搜索树的官方定义：平衡二叉查找树：简称平衡二叉树。是由前苏联的数学家 Adelse-Velskil和 Landis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。它具有如下几个性质： 性质1. 可以是空树。 性质2 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1（如果读者还不清楚平衡二叉搜索树的概念，可以先查阅前文 **动画：什么是平衡二叉树**，本文不再详细介绍平衡二叉搜索树）三. 2-3树经过上面的例子，我们可以知道，构建一棵平衡的二叉搜索树的关键在于选取“正确”的根节点，那么我们如何在每次构建平衡二叉搜索树时都能选取合适的根节点呢，这里就要用到另一种重要的树：2-3树（读作二三树），2-3树和红黑树是等价的，理解2-3树对理解红黑树以及B类树都有很大的帮助。2-3树的基本概念所谓2-3树，即满足二叉搜索树的性质，且节点可以存放一个元素或者两个元素，每个节点有两个或三个孩子的树。性质1：满足二叉搜索树的性质性质2： 节点可以存放一个或两个元素性质3： 每个节点有两个或三个子节点2-3树本质上也是一棵搜索树，和二叉搜索树的区别在于，2-3的节点可能存放 2 个元素，而且每个节点可能拥有 3 个子节点。2-3树存在以下两种节点：2-节点（存在两个子节点）和3-节点（存在3个子节点）
![img](https://pic2.zhimg.com/v2-064ae7dc869b8f284ad1fba6fccf8439_b.jpg)
2-3树的创建下面我们来看如何创建一棵2-3树，创建2-3树的规则如下：规则1. 加入新节点时，不会往空的位置添加节点，而是添加到最后一个叶子节点上 规则2. 四节点可以被分解三个2-节点组成的树，并且分解后新树的根节点需要向上和父节点融合我们依然使用上面的示例数组[42，37，18，12，11，6，5]，依然使用顺序插入的方式来构建2-3树，看看是否会出现退化成链表的情况。
![img](https://pic2.zhimg.com/v2-78978e7113766201ca035480a3cbb3f1_b.jpg)

![img](https://pic1.zhimg.com/v2-64869d114d95e4ecc7cfb2d5bcca3a6c_b.jpg)

![img](https://pic2.zhimg.com/v2-7edd116dc4c21c6d55e383e65e2bd771_b.jpg)

![img](https://pic1.zhimg.com/v2-ec1e1024f3f1aafc6c7e272c367c55c0_b.jpg)

![img](https://pic4.zhimg.com/v2-61d139a1b853783a7dff3343712cabd7_b.jpg)
我们可以注意到，在创建2-3树的每一步中，整棵树始终保持平衡。既然2-3树已经能够保持自平衡，为什么我们还需要一棵红黑树呢，这是因为 **2-3树这种每个节点储存1~2个元素以及拆分节点向上融合的性质不便于代码操作**，因此我们希望通过一些规则，将2-3树转换成二叉树，且转换后的二叉树依然能保持平衡性。2-3树和红黑树的等价性本小节我们以一棵2-3树为例，将其从2-3树转换成为一棵红黑树，从而学习了解2-3树和红黑树的转换规则，并体会2-3树和红黑树之间的等价性。对于2-3树中的2-节点来说，本身就和二叉搜索树的节点无异，可以直接转换为红黑树的一个黑节点，但是对于3-节点来说，我们需要进行一点小转换：将3-节点拆开，成为一棵树，并且3-节点的左元素作为右元素的子树
将原来的左元素标记为红色（表示红色节点与其父节点在2-3树中曾是平级的关系）

![img](https://pic4.zhimg.com/v2-3b4031b480dbc6406ff0eee8d8fad583_b.jpg)
我们来转换一棵复杂点的2-3树，根据上边的两条转换规则，我们将2-节点直接转换为黑色节点，将3-节点拆成一棵子树，并给左元素标上红色，这个过程应该不难理解，另外我们可以注意到，由于红色节点是由3-节点拆分而来，因此所有的红色节点都只会出现在左子树上。
![img](https://pic1.zhimg.com/v2-fd1c14f000cc3d898c68126161e71168_b.jpg)
四. 红黑树的性质和复杂度分析红黑树基本性质分析在完成了2-3树到红黑树的转换之后，我们重新审视红黑树的五条性质：(1) 每个节点或者是黑色，或者是红色这是红黑树的定义，没什么好说的。(2) 根节点是黑色根节点要么对应2-3树的2-节点或者3-节点，而这两者的根节点都是黑色的，因而根节点必然是黑色。从上图2-3树节点和红黑树节点对应关系就能很容易看出来(3) 每个叶子节点是黑色注意，这里的叶子是指的为空的叶子节点，上图的红黑树的完整形式应该是这样的：
![img](https://pic4.zhimg.com/v2-6c2e677cd22dcda31ff34f5f048b53b7_b.jpg)
(4) 如果一个节点是红色的，则它的子节点必须是黑色的由于红黑树的每个节点都由2-3树转换而来，红色节点连接的节点必然是一个2-节点或者3-节点，而无论是2-节点还是3-节点，其根节点都是黑色的，因此红色节点的子节点必然是黑色的(5) 从任意一个节点到叶子节点，经过的黑色节点是一样多的这是红黑树最重要的一条性质，也是红黑树的价值所在。由于红黑树是由2-3树转换而来，因此每一个黑色节点必然对应2-3树的某个2-节点或者3-节点，因此红黑树的黑节点也能拥有2-3树的平衡性。如果对这条性质还不够理解，可以对着上文2-3树和红黑树的转换图再理解理解。红黑树时间复杂度分析网上有很多使用数学归纳法来计算红黑树时间复杂度的证明了，这里就不再赘述。我们可以简单思考一下，对于一棵普通的平衡二叉搜索树来说，它的搜索时间复杂度为O(logn)，而作为红黑树，存在着最坏的情况，也就是查找的过程中，经过的节点全都是原来2-3树里的3-节点，导致路径延长两倍，时间复杂度为O(2logn)，由于时间复杂度的计算可以忽略系数，因此红黑树的搜索时间复杂度依然是O(logn)，当然，由于这个系数的存在，在实际使用中，红黑树会比普通的平衡二叉树（AVL树）搜索效率要低一些。
![img](https://pic4.zhimg.com/v2-e86b8808b5f7a9e8201766e32c12a39f_b.jpg)
既然红黑树的效率比AVL树的效率低，那么红黑树的优势体现在哪呢？事实上，红黑树的优势体现在它的插入和删除操作上，红黑树的插入和删除相较于AVL树的性能会高一些，在后续红黑树的创建章节中，读者应该能够体会到红黑树在调整树平衡操作上的优势。五. 红黑树的创建上文中我们讲解了如何由2-3树转换一棵红黑树，下面我们就来看看如何不经过2-3树直接创建一棵红黑树，毕竟我们写代码的时候不能先创建一棵2-3树再转化成红黑树吧。我们回想一下2-3树的创建规则：规则1. 加入新节点时，不会往空的位置添加节点，而是添加到最后一个叶子节点上 规则2. 四节点可以被分解三个2-节点组成的树，并且分解后新树的根节点需要向上和父节点融合简单来说，2-3树的创建分为**「融合」和「拆分」两步**，为了实现这两步，我们需要在创建二叉树的基础操作上增加另外几个操作，分别是：保持根节点黑色
左旋转
右旋转
颜色翻转
保持根节点黑色和左旋转由于我们往2-3树插入节点时做的都是融合，因此新加入的节点和原位置的节点是平级关系，所以我们往红黑树里增加节点的时候，增加的都是红色节点。
![img](https://pic1.zhimg.com/v2-885e12219fd8c2965be2cb7d76df5448_b.jpg)
我们插入第一个红色节点42，哦吼，第一步就与红黑树的性质2「根节点是黑色」冲突，为了解决这种冲突，**我们将根节点变成黑色。**
![img](https://pic3.zhimg.com/v2-35f0baa2d84a5238dfe42deb369547a2_b.jpg)
下面我们继续插入节点37，同样的，新插入的节点都为红色
![img](https://pic4.zhimg.com/v2-2238155deb632031facfc6c01c3e6df7_b.jpg)
这里我们要思考一下，如果我们颠倒顺序，先插入 37 再插入 42 呢，是直接把 42 加到 37 的右子树上么，这显然是错误的，因为在前边2-3树转红黑树的过程中，我们已经了解到，所有的红色节点都只会出现在左子树上，因此我们需要进行**左旋转**，将节点的位置和颜色旋转过来。
![img](https://pic4.zhimg.com/v2-4134e7293ba39e8cb780e87cd6886287_b.jpg)
上面是两个独立的节点，如果节点拥有左右子树，在旋转后仍然能满足二叉搜索树的性质吗，我们需要推广到一般情形。我们来看一个例子：
![img](https://pic1.zhimg.com/v2-c7f1f005515274988387ea50aba433cc_b.jpg)

![img](https://pic4.zhimg.com/v2-51735d16f796b74b59e2d9579002dcfb_b.jpg)

![img](https://pic4.zhimg.com/v2-1e6934b0ac5813f6f062d4297affa30b_b.jpg)

![img](https://pic3.zhimg.com/v2-ee0c4391ad514ca57a34358645b9903a_b.jpg)
经过以上几步，我们就完成了一般情形下的左旋转，我们可以对应地写几句伪代码，这里把 37 称作node，42 称作 target`function leftRotate(node) {     node.right = target.left     target.left = node     target.color = node.color     node.color = RED }`颜色翻转上一小节我们介绍了左旋转的情形，其实左旋转的情形就对应着2-3树中生成3-节点的情形，也就是从2-节点到3-节点这一步，那么从3-节点到4-节点，再到拆分4-节点的这一步又对应红黑树的什么操作呢，我们来看一个简单的例子。我们以一棵已经拥有两个节点的红黑树为例，现在这一红一黑两个节点就对应了2-3树的3-节点[37 42]，我们加入新的红色节点 66 ，节点 66 按照二叉搜索树的原则，暂时加在节点 42 的右子树上。之前我们说过，红色节点表示该节点与其父节点在2-3树中是平级关系，也就是说这种左右子节点都是红色节点的情况其实对应了2-3树中临时的4-节点。当然，我们知道红色的节点是只能出现在左子树上，所以我们需要进行一些变形。
![img](https://pic3.zhimg.com/v2-b9033423a6b69d73f906af0747db9d96_b.jpg)

![img](https://pic1.zhimg.com/v2-c931a77c15c112ed9dfb95d6642746bc_b.jpg)
我们应该如何把这棵临时的不规范的红黑树转换成一棵正确的红黑树呢，回想2-3树拆分4-节点的过程：4-节点被拆分为3个2-节点，拆分后的子树的根节点向上融合。由于2-节点对应着红黑树中的黑色节点，因此我们直接把左右子树上的37和66直接翻转为黑色，此即**颜色翻转。**由于根节点还需要向上融合，因此我们把根节点再标记为红色（相当于加入新节点）
![img](https://pic3.zhimg.com/v2-608c0f0fe3a18d3c68c17b04e04a2166_b.jpg)

![img](https://pic4.zhimg.com/v2-a2e57d1d38cbc4ed64da79061eab011b_b.jpg)
我们写两句代码，毕竟这些翻来覆去的操作不是给人看的，是给机器看的。代码非常简单，就是把根节点变成红色，左右子元素变成黑色。当然只有像上图这种树结构（根节点黑色而左右子元素红色）才适用这种颜色翻转。`function flipColors(node) {    node.color = RED    node.left.color = BLACK    node.right.color = BLACK }`右旋转我们刚才插入了节点66，66比42大，因此被加入到了节点42的右子树上，然后我们使用颜色翻转就完成了转换。然而节点并不总是被添加到右子树上，比如说插入节点12，12小于37，因此节点12被加入到37的左子树上：
![img](https://pic2.zhimg.com/v2-64be772b3ea99c0eead00018c94631fd_b.jpg)
对于这种情况，我们需要进行**右旋转**，我们直接以一般情况来讲解：
![img](https://pic4.zhimg.com/v2-3c695b9dabf9b5d67c7b6320296339c7_b.jpg)

![img](https://pic3.zhimg.com/v2-dfde1cfd1a5d58dafcad2acc509b1fca_b.jpg)

![img](https://pic1.zhimg.com/v2-6466d224ec68ee1169d5990ed2e863d0_b.jpg)
经过以上几步，我们就完成了一般情形下的右旋转，我们可以对应地写几句伪代码，这里把 37 称作target，42 称作 node。`function rightRotate(node) {      node.left = T1      target.right = node      target.color = node.color      node.color = RED }`其他情况我们通过颜色翻转和右旋转，解决了往3-节点添加节点的两种情况，分别是大于b节点情况，小于a节点的情况，那么如果插入的节点大于 a 而小于 b 呢。
![img](https://pic3.zhimg.com/v2-84e18894ce20884985c6203b77c99412_b.jpg)
对于上图的第三种情况，我们需要结合左旋转、右旋转、颜色翻转等子过程来调整成为一棵正确的红黑树，下面以[37 40 42]作为例子：
![img](https://pic1.zhimg.com/v2-80abb6abcb54a1c5f6f44b2ab942ce40_b.jpg)

![img](https://pic1.zhimg.com/v2-475dd23efaa8e83f019b33cdc16aab18_b.jpg)

![img](https://pic3.zhimg.com/v2-fe3e57082f7ba35e5d1e51a0849cd4f2_b.jpg)
流程总结我们总结一下以上三种情形，会发现其实红黑树插入节点不过五种形式*1*. 插入到一个2-节点，且节点小于该2-节点
![img](https://pic4.zhimg.com/v2-ab6255c4d689a91f592af14e9f6c1767_b.jpg)
*2*. 插入到一个2-节点，且节点大于该2-节点
![img](https://pic4.zhimg.com/v2-db022f28b27ee63cf0f33e4ee75aa883_b.jpg)
*3*. 插入到一个3-节点，且插入节点小于3-节点的两个节点
![img](https://pic2.zhimg.com/v2-741785bcd2716da972588dc0e8520265_b.jpg)
*4*. 插入到一个3-节点，且插入节点大于3-节点的两个节点
![img](https://pic4.zhimg.com/v2-14f5856536e73391e1df2eceadd1b67b_b.jpg)
*5*. 插入到一个3-节点，且插入节点在3-节点的两个节点之间
![img](https://pic3.zhimg.com/v2-344fd4b4381653020977d33532ff8332_b.jpg)
其实这五种形式都可以用一个逻辑链条来表示，我们回顾一下6.4里，插入的节点小于a大于b的转换过程，出于通用性，我把具体数字隐去了。
![img](https://pic3.zhimg.com/v2-57cfea18e4019dcc1ceef9a4c92a4dc6_b.jpg)
我们发现，这个流程已经包含了以上五种情况，如果我们插入的节点大于a也大于b，那么我们可以直接跳到第四步，然后进行颜色翻转；如果我们插入的节点小于a也小于b，那么跳到第三步；如果插入节点在ab之间，那么就对应第二步。
![img](https://pic3.zhimg.com/v2-6a89118f43d42b273e7c8a3a672950d6_b.jpg)
有了这个逻辑流程，我们的代码一下子清晰起来，我们只需要通过几个条件判断，就能描述红黑树所有旋转方式，下面我们来写一段代码：`function add(node) {      //如果右节点为红色,左节点为黑色, 那么进行左旋转, 对应情况2      if(isRed(node.right) && !isRed(node.left)) node = leftRotate(node)       //如果左节点为红色,左节点的左节点也为红色, 那么进行右旋转, 对应情况3      if(isRed(node.left) && isRed(node.left.left)) node = rightRotate(node)         //如果左右节点都为红色, 那么进行颜色翻转, 对应情况4      if(isRed(node.left) && isRed(node.right)) flipColors(node) }`到这里，我们就实现了红黑树的所有平衡操作，从这个过程中，我们还能得出一个重要结论，即**红黑树任何不平衡，都能在3次旋转内得到解决**，这也就是红黑树相较AVL树的优势所在。六. 红黑树和AVL树的比较**1**. AVL树比红黑树更为平衡，其搜索效率也好于红黑树, 经过我们之前的分析可以知道, 红黑树在最坏的情况下搜索时间复杂度为2logn，大于AVL树的logn。AVL树是严格平衡，红黑树只能达到“黑平衡”，即从任意节点出发到叶子节点经过的黑节点数量相同，但经过的红色节点数量不确定，最差的情况下，经过的红色节点和黑色节点一样多。**2**. 红黑树增删节点的性能优于AVL树，当我们往红黑树增加节点或删除节点引起红黑树不平衡，我们只需要最多三次旋转就能解决，而相同条件下，AVL树的旋转次数要多于红黑树，因此红黑树在增删节点上相较于AVL树更优七.总结最后做个概括，红黑树是以牺牲部分搜索性能换取增删性能的折中方案，用非严格的平衡，换取旋转次数的减少。在实际使用中，如果所维护的树需要频繁增删节点，红黑树会更加合适，反之，则适合AVL树