# Programming Concurrency on the JVM

速度。除了咖啡因之外，没有什么能像快速地执行一段代码那样加快程序员的工作了。我们如何满足对计算速度的需求？摩尔“定律把我们的一些方式，但多是真正的未来。要充分利用多核，我们需要在编程时考虑并发性。

在并发程序中，两个或多个动作同时发生。并发程序可以在执行计算和更新数据库的同时下载多个文件。我们经常使用Java中的线程编写并发程序。多线程Java虚拟机（JVM）从一开始就存在了，但我们的程序并发怎么还在不断发展，为我们'会在这本书中学习。

困难的部分是在不被烧毁的情况下收获并发的好处。启动线程很容易，但是它们的执行顺序是不确定的。我们“重新很快被拉入战来协调线程，并确保他们”再持续地处理数据。

为了快速从A点到达B点，我们基于行进时间的紧迫性，交通状况，预算等等，有几种选择。我们可以步行，乘公交车，驾驶那辆笨拙的敞篷车，乘坐子弹头火车或乘坐喷气式飞机。在速度编写Java，我们'以前也有选择。

JVM上有三种主要的并发选项：

•我所说的“同步和痛苦”模型

•软件事务存储模型

•基于参与者的并发模型

What I call the “synchronize and suffer” model

• The Software-Transactional Memory model

• The actor-based concurrency model

我将熟悉的Java开发工具包（JDK）同步模型称为“同步并受苦”，因为如果我们忘记同步共享的可变状态或以错误的级别对其进行同步，则结果是不可预测的。如果我们'重新幸运，我们赶上发展过程中的问题; 如果我们想念，它可以在生产过程中以奇怪和不幸的方式出现。我们不会得到编译错误，没有警告，并且不会遇到那些命运多code的代码。

在制作过程中以奇怪和不幸的方式出现。我们没有得到任何编译错误，没有任何警告，简单地说，没有任何迹象表明这个倒霉的代码有问题。无法同步访问共享可变状态的程序被破坏了，但是Java编译器不会告诉我们这一点。在纯Java中编写具有可变性的程序就像与等待您失败的婆婆一起工作。我相信你已经感受到了痛苦。

在编写并行程序时，有三种方法可以避免问题:

•正确同步。

•不要共享状态。

•不要发生变异状态。

如果我们用现代的JDK并发API，我们'将不得不投入显著努力正确地同步。STM隐含了同步，并大大减少了出错的机会。另一方面，基于参与者的模型可以帮助我们避免共享状态。避免易变的状态是赢得并发战斗的秘密武器。

在这本书中，我们'会举一个例子驱动的方法来学习的三种模式，以及如何与他们利用并发。

### Is it Concurrency or Parallelism?是并发还是并行

有“在行业中的这两个词之间没有明显的区别，而我们答案的数目” LL听到的是接近我们要求一个解释的人的数量（和Don '牛逼问他们同时......或者我应该并行说？）。

让“不在这里讨论的区别。我们可能会在具有多个线程的单个内核上运行程序，然后将它们部署在具有多个线程的多个内核上。当我们的代码在单个JVM中运行时，这两个部署选项都存在一些共同的问题-我们如何创建和管理线程，如何确保数据的完整性，如何处理锁和同步以及线程是否跨越内存？在适当的时间设置障碍...？

无论是并行还是并行，解决这些问题都是确保程序正确有效运行的核心。这“就是我们”会专注于这本书。



### 多语言程序员的并发

如今，*Java*一词代表的是平台而不是语言。多年来，Java虚拟机以及无处不在的库已演变成一个非常强大的平台。同时，Java语言正在显示其时代。今天，有相当一些有趣而强大的语言在JVM上-的Clojure，JRuby的，Groovy和Scala，仅举几例。

这些现代JVM语言中的一些语言（例如Clojure，JRuby和Groovy）是动态键入的。某些功能（例如Clojure和Scala）受编程功能样式的影响很大。然而他们所有人都有一件事在常见的-他们'再简洁，极富表现力。虽然它可能需要一些努力来适应自己的语法，范式，或差异，我们'会大多需要在所有这些语言与Java编程相比，更少的代码。什么“就更好了，我们可以混合使用这些语言与Java代码，并真正成为一个通晓多国语言的程序员-看尼尔福特”小号“多语种程序员”[在](part160.htm#bookmark221)[附录2，](part160.htm#bookmark221)[Web资源](part160.htm#bookmark221)，255页。

在这本书中，我们'将学习如何使用的java.util.concurrent API中，STM，并使用Akka 和GPars的基于角色的模型（the actor-based model）。我们“也将学习如何用Clojure，Java中的JRuby，Groovy和Scala亲克并发。如果您编程或打算使用这些语言中的任何一种，本书将向您介绍其中的并发编程选项。

### 示例和性能衡量

本书中的大多数示例都使用Java。但是，您还将在Clojure，Groovy，JRuby和Scala中看到很多示例。我'已经采取额外的努力来保持语法的细微差别和特定语言的成语到最低限度。哪里有选择，我“已经俯身向着东西，”这样比较方便阅读和熟悉的程序员大多与Java舒服。

以下是本书中使用的语言和库的版本：

• [Akka 1.1.3（](http://akka.io/downloads)http://akka.io/downloads ）

• [Clojure 1.2.1（](http://clojure.org/downloads)http://clojure.org/downloads ）

• [Groovy 1.8（](http://groovy.codehaus.org/Download)http://groovy.codehaus.org/Download ）

• [GPars 0.12（](http://gpars.codehaus.org/)http://gpars.codehaus.org ）

• [Java SE 1.6（](http://www.java.com/en/download)http://www.java.com/en/download ）

• [JRuby 1.6.2（](http://jruby.org/download)http://jruby.org/download ）

• [Scala 2.9.0.1（](http://www.scala-lang.org/downloads)http://www.scala-lang.org/downloads ）

当显示的代码两个版本之间性能的措施，我'已经确定这些比较是在同一台机器上进行。对于大多数的例子我'已经使用与2.8GHz的英特尔双核处理器和4GB内存运行Mac OS X 10.6.6和Java 1.6版更新中的MacBook Pro

24.对于某些示例，我还使用具有8GB内存的八核Sunfire 2.33GHz处理器，运行64位Windows XP和Java 1.6版。

除非另有说明，否则所有示例均使用“ Java HotSpot TM 64位服务器VM ” Java虚拟机在服务器模式下运行。

所有示例均已编译并在前面提到的Mac和Windows计算机上运行。

在的代码示例上市，我还'吨所示的导入语句（和封装的语句），因为这些往往变得冗长。当试图代码示例，如果你“不能确定类属，不要这包”别担心，我'[已经包含代码的网站上的完整列表。继续并从其网站（](http://pragprog.com/titles/vspcon)）[下载本书的完整源代码](http://pragprog.com/titles/vspcon)。



### 1.1线程：执行流程 Threads: The Flow of Execution

众所周知，线程是流程中的执行流程。当我们运行一个程序时，其过程至少有一个执行线程。我们可以创建线程来启动其他执行流程，以便同时执行其他任务。我们使用的库或框架可能还会根据需要在后台启动其他线程。

当多个线程作为单个应用程序或JVM的一部分运行时，我们将同时运行多个任务或操作。并发应用程序利用多个线程或并发执行流。

在单个处理器上，这些并发任务通常是多路复用或多任务的。也就是说，处理器在每个执行流的上下文之间快速切换。但是，在任何给定实例上只执行一个线程，因此只有一个执行流。在多核处理器上，在任何给定的实例上都要执行多个执行流(线程)。这个数字取决于处理器上可用的内核数量，而应用程序的并发线程数量则取决于与其进程相关联的内核数量。

### 1.2并发的威力

 我们对并发感兴趣有两个原因:使应用程序响应/改善用户体验和使其更快。

 让应用程序响应更快**Making Apps More Responsive**

当我们开始一个应用程序,主线程的执行通常需要在多个责任顺序,取决于我们的行动让它执行:接收来自用户的输入,读取一个文件,执行一些它——一代长大成人,访问一个web服务,更新数据库,显示一个响应给用户,等等。如果每个操作只花费几分之一秒的时间，那么就没有必要引入额外的执行流;一个线程就足够满足需要了。

然而，在大多数重要的应用程序中，这些操作可能没有那么快。计算可能需要几秒钟到几分钟的时间。对该web服务的数据请求可能会遇到网络延迟，因此线程会等待响应的到达。当发生这种情况时，应用程序的用户无法与应用程序交互或中断应用程序，因为单个线程被扣留在某个要完成的操作上。

让我们考虑一个示例，该示例说明了需要多个线程以及它如何影响响应性。我们经常为事件计时，所以最好有秒表应用程序。我们可以点击一个按钮开始手表，它将运行，直到我们再次点击按钮。下面显示了为此编写的1位代码(只显示按钮的动作处理程序;你可以从这本书的网站下载完整的程序):

在示例中，我们将简单地传播异常，而不是记录或处理它们——但请确保在您的生产代码中正确地处理异常。

```java
//This will not work

public void actionPerformed(final ActionEvent event) {

if (running) 
    stopCounting(); 
    else startCounting();

}

private void startCounting() { 
    startStopButton.setText("Stop");
    running = true;

for(int count = 0; running; count++) { timeLabel.setText(String.format("%d", count));
try {

Thread.sleep(1000);

} catch(InterruptedException ex) {

throw new RuntimeException(ex);

}

}

}

private void stopCounting() { 
    running = false; 
    startStopButton.setText("Start");

}


```

当我们运行这个小小的秒表应用程序时，将出现一个带有开始按钮和0标签的窗口。不幸的是，当我们单击按钮时，我们不会看到任何更改按钮没有更改为停止，并且标签没有显示时间计数。更糟糕的是，应用程序甚至不会响应退出请求。主事件分派线程负责注意与ui相关的事件并委托要执行的操作。当单击开始按钮时，主事件调度线程进入事件处理程序actionPerformed();在开始计数时，它被startCounting()方法扣留。现在，当我们单击按钮或尝试退出时，这些事件会被拖放到事件队列中，但主线程太忙，永远不会响应这些事件。

我们需要一个额外的线程，或者一个计时器，反过来使用额外的线程，以使应用程序能够响应。我们需要委托计数任务，并减轻主要事件分派线程的责任。

线程不仅可以帮助应用程序响应，还可以帮助增强用户体验。应用程序可以预先查看用户接下来可能执行的操作，并执行必要的操作，例如索引或缓存用户需要的某些数据。

**Making Apps Faster**

看看你写的一些应用程序。您是否看到当前按顺序依次执行的操作可以并发执行?通过在不同的线程中运行这些操作，可以使应用程序运行得更快。

通过使用并发，相当多的应用程序可以运行得更快。其中包括服务、计算密集型应用程序和数据处理应用程序。

**Services**

假设我们的任务是构建一个需要处理来自不同供应商的大量发票的应用程序。这要求我们对每个发票应用规则和业务工作流，但是我们可以按照任何顺序处理它们。按顺序处理这些发票不会产生吞吐量，也不会很好地利用这些资源。我们的应用程序需要同时处理这些发票。

**Computationally Intensive Apps**  计算密集型应用

我曾经在化工行业工作过，在那里我编写了一些应用程序，用来计算流经炼油厂不同单元的化学物质的各种属性。这涉及到密集的计算，这些计算很容易从将问题划分为几个部分、并发地运行计算并最终合并部分结果中获益。各种各样的问题都适合采用分而治之的方法，它们很容易从我们编写并发程序的能力中获益。

**Data Crunchers** 计算数据

我曾经被要求构建一个个人财务应用程序，该应用程序必须通过web服务来获取大量股票的价格和其他细节。应用程序必须向用户提供总资产价值和每只股票交易量的详细信息。对于富有的用户，应用程序可以跟踪100种不同股票的股票。在流量大的时候，可能需要几秒钟才能从网络上接收到信息。在接收到所有数据并开始处理之前，用户需要等待几分钟。通过将请求委托给多个线程，等待时间可以缩短到一两秒，假设每个请求的网络延迟为一两秒，并且运行应用程序的系统有足够的资源和能力来产生数百个线程。

### 获得并发的好处

并发性可以帮助使应用程序具有响应性，减少延迟，并增加吞吐量。我们可以利用硬件的多核和应用程序中任务的一致性来提高速度和响应能力。然而,有一些困难的挑战,我们将讨论下,我们必须解决之前我们可以获得这些好处。‌