# Algorithms

Algorithms FOURTH EDITION Robert Sedgewick andKevin Wayne Princeton University


​		这本书的目的是为解决适合于计算机实现的问题研究广泛的各种重要和有用的算法方法。算法与组织数据的数据结构方案携手并进，使它们服从于算法的有效处理。本章介绍了我们学习算法和数据结构所需要的基本工具。

首先，我们介绍基本的编程模型。我们所有的程序都是使用Java编程语言的一个小子集以及我们自己的一些用于输入/输出和统计计算的库来实现的。1.1节是对本书中使用的语言结构、特性和库的总结。
		接下来，我们强调数据抽象，我们在模块编程中定义抽象数据类型(ADTs)。
在1.2节中，我们将通过指定应用程序编程接口(API)，然后使用Java类机制开发用于客户端代码的实现，来介绍用Java实现ADT的过程。

作为重要而有用的示例，我们接下来考虑三个基本adt:包、队列和堆栈。（the
bag, the queue, and the stack.）第1.3节描述了使用数组、调整数组和链表作为算法实现的模型和起点的包、队列和堆栈的api和实现。

性能是研究算法的中心考虑因素。第1.4节描述了我们分析算法性能的方法。我们的方法是以科学的方法为基础的:我们开发关于性能的假设，创建数学模型，并运行实验来测试它们，必要时重复这个过程。最后，我们通过一个案例研究来考虑连接问题的解决方案，该解决方案使用实现经典union-find ADT的算法和数据结构。

当我们编写一个计算机程序时，我们通常是在实现一种以前为解决某个问题而设计的方法。这种方法通常独立于所使用的特定编程语言，它可能同样适用于许多计算机和许多编程语言。是方法，而不是计算机程序本身，指定了我们可以采取的解决问题的步骤。在计算机科学中，“算法”一词用于描述一种适用于作为计算机程序实现的有限的、确定的和有效的解决问题的方法。算法是计算机科学的东西:它们是该领域研究的中心对象。

我们可以定义一个算法通过描述自然语言过程中解决问题,或通过编写计算机程序,实现了过程,如图所示在对欧几里德算法寻找两个数的最大公约数,是2300多年前发明的一种变体。如果您不熟悉欧几里得算法，建议您在阅读完1.1节之后再做练习1.1.24和练习1.1.25。

>Compute the greatest common divisor of
>two nonnegative integers p and q as follows:
>If q is 0, the answer is p. If not, divide p by q
>and take the remainder r. The answer is the
>greatest common divisor of q and r.

```java
public static int gcd(int p, int q){
if (q == 0) return p;
int r = p % q;
return gcd(q, r);
}
//Euclid’s algorithm 欧几里德算法
```

在这本书中，我们使用计算机程序来描述算法。这样做的一个重要原因是，它使得根据需要检查它们是否有限、确定和有效的任务变得更容易。但同样重要的是要认识到，用特定语言编写的程序只是表示算法的一种方式。

​		在过去的几十年里，这本书中的许多算法都是用多种编程语言表达的，这一事实强化了这样一种观点:

​		每种算法都是一种适合在任何计算机上用任何编程语言实现的方法。我们感兴趣的大多数算法都涉及到组织计算中涉及的数据。这样的组织导致了数据结构，这也是计算机科学研究的中心对象。算法和数据结构是密切相关的。在这本书中，我们采取的观点，数据结构作为算法的副产品或最终产品而存在，我们必须因此研究他们，以理解算法。简单的算法可以产生复杂的数据结构，反之，复杂的算法可以使用简单的数据结构。在这本书中，我们将研究许多数据结构的性质;事实上，我们完全可以给《算法和数据结构》起个标题。

​		当我们使用计算机来帮助我们解决问题时，我们通常会面临许多可能的方法。对于小问题，我们用什么方法并不重要，只要我们有一个正确解决问题的方法。然而，对于重大问题(或需要解决大量小问题的应用程序)，我们很快就会有动力去设计有效利用时间和空间的方法。

学习算法的主要原因是，这一学科给我们带来了潜在的巨大节省，甚至使我们能够完成一些任务，否则是不可能的。在一个处理数百万对象的应用程序中，通过使用设计良好的算法，使程序速度提高数百万倍是很正常的。我们将在整本书中看到许多这样的例子。相比之下，投资额外的金钱或时间来购买和安装一台新电脑，可能只会使程序的速度提高10倍或100倍。在解决重大问题的过程中，仔细的算法设计是极其有效的一部分，无论应用领域是什么。

当开发一个巨大或复杂的计算机程序时，必须花费大量的精力来理解和定义要解决的问题，管理其复杂性，并将其分解为易于实现的更小的子任务。通常，在分解之后需要实现的许多算法都很简单。然而，在大多数情况下，有一些算法的选择是关键的，因为大多数系统资源将用于运行这些算法。这些是我们在本书中所集中讨论的算法类型。我们研究的基本算法是有用的解决具有挑战性的问题在广泛的应用领域。

计算机系统中的程序共享正变得越来越普遍，因此，尽管我们可能期望使用本书中的大部分算法，但我们也可能期望只能实现其中的一小部分。例如，Java库包含许多基本算法的实现。但是，实现基本算法的简单版本有助于我们更好地理解它们，从而更有效地使用和调优库的高级版本。更重要的是，重新实现基本算法的机会频繁出现。这样做的主要原因是，我们经常面对全新的计算环境(硬件和软件)，这些环境带有旧实现可能无法充分利用的新特性。在这本书中，我们集中在最简单合理的最佳算法的实现。我们会仔细地编写算法的关键部分，并注意到底层优化工作在哪些地方最有好处。

为特定任务选择最佳算法可能是一个复杂的过程，可能涉及复杂的数学分析。计算机科学的一个分支包括了对这些问题的研究，叫做算法分析。

分析表明，本文所研究的算法具有良好的理论性能;还有一些人只是因为经验而出名。我们的主要目标是为重要的任务学习合理的算法，但我们也将仔细关注方法的性能比较。我们不应该在不知道它会消耗哪些资源的情况下使用算法，所以我们要努力了解我们的算法可能会如何执行。

## tree树

之前介绍的所有的数据结构都是线性存储结构。本章所介绍的树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\2-1FS0094003158.png)

​													图一：（A）        									 （B）

如图：是使用树结构存储的集合 {A,B,C,D,E,F,G,H,I,J,K,L,M} 的示意图。对于数据 A 来说，和数据 B、C、D 有关系；对于数据 B 来说，和 E、F 有关系。这就是“一对多”的关系。

将具有“一对多”关系的集合中的数据元素按照图 （A）的形式进行存储，整个存储形状在逻辑结构上看，类似于实际生活中倒着的树（图 （B）倒过来），所以称这种存储结构为“树型”存储结构。

### 树的结点

结点：使用树结构存储的每一个数据元素都被称为“结点”。例如，图 1（A）中，数据元素 A 就是一个结点；

父结点（双亲结点）、子结点和兄弟结点：对于图 1（A）中的结点 A、B、C、D 来说，A 是 B、C、D 结点的父结点（也称为“双亲结点”），而 B、C、D 都是 A 结点的子结点（也称“孩子结点”）。对于 B、C、D 来说，它们都有相同的父结点，所以它们互为兄弟结点。

树根结点（简称“根结点”）：每一个非空树都有且只有一个被称为根的结点。图 1（A）中，结点A就是整棵树的根结点。

树根的判断依据为：如果一个结点没有父结点，那么这个结点就是整棵树的根结点。

叶子结点：如果结点没有任何子结点，那么此结点称为叶子结点（叶结点）。例如图 1（A）中，结点 K、L、F、G、M、I、J 都是这棵树的叶子结点。

### 子树和空树

子树：如图 1（A）中，整棵树的根结点为结点 A，而如果单看结点 B、E、F、K、L 组成的部分来说，也是棵树，而且节点 B 为这棵树的根结点。所以称 B、E、F、K、L 这几个结点组成的树为整棵树的子树；同样，结点 E、K、L 构成的也是一棵子树，根结点为 E。

> 注意：单个结点也是一棵树，只不过根结点就是它本身。图 1（A）中，结点 K、L、F 等都是树，且都是整棵树的子树。

知道了子树的概念后，树也可以这样定义：树是由根结点和若干棵子树构成的。

空树：如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。

补充：在树结构中，对于具有同一个根结点的各个子树，相互之间不能有交集。例如，图 1（A）中，除了根结点 A，其余元素又各自构成了三个子树，根结点分别为 B、C、D，这三个子树相互之间没有相同的结点。如果有，就破坏了树的结构，不能算做是一棵树。

### 结点的度和层次

对于一个结点，拥有的子树数（结点有多少分支）称为结点的度（Degree）。例如，图 1（A）中，根结点 A 下分出了 3 个子树，所以，结点 A 的度为 3。

一棵树的度是树内各结点的度的最大值。图 1（A）表示的树中，各个结点的度的最大值为 3，所以，整棵树的度的值是 3。

结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。对于图 1（A）来说，A 结点在第一层，B、C、D 为第二层，E、F、G、H、I、J 在第三层，K、L、M 在第四层。

一棵树的深度（高度）是树中结点所在的最大的层次。图 1（A）树的深度为 4。

如果两个结点的父结点虽不相同，但是它们的父结点处在同一层次上，那么这两个结点互为堂兄弟。例如，图 1（A）中，结点 G 和 E、F、H、I、J 的父结点都在第二层，所以之间为堂兄弟的关系。

### 有序树和无序树

如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树。

在有序树中，一个结点最左边的子树称为"第一个孩子"，最右边的称为"最后一个孩子"。

拿图 1（A）来说，如果是其本身是一棵有序树，则以结点 B 为根结点的子树为整棵树的第一个孩子，以结点 D 为根结点的子树为整棵树的最后一个孩子。

### 森林

由 m（m >= 0）个互不相交的树组成的集合被称为森林。图 1（A）中，分别以 B、C、D 为根结点的三棵子树就可以称为森林。

前面讲到，树可以理解为是由根结点和若干子树构成的，而这若干子树本身是一个森林，所以，树还可以理解为是由根结点和森林组成的。用一个式子表示为：

Tree =（root,F）

其中，root 表示树的根结点，F 表示由 m（m >= 0）棵树组成的森林。

### 树的表示方法

除了图 1（A）表示树的方法外，还有其他表示方法：

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\2-1FS00952413Y.png)

 


​                                                                                  （A）                     （B）

​																						图2 树的表示形式

图 2（A）是以嵌套的集合的形式表示的（集合之间绝不能相交，即图中任意两个圈不能相交）。

图 2（B）使用的是凹入表示法（了解即可），表示方式是：最长条为根结点，相同长度的表示在同一层次。例如 B、C、D 长度相同，都为 A 的子结点，E 和 F 长度相同，为 B 的子结点，K 和 L 长度相同，为 E 的子结点，依此类推。

最常用的表示方法是使用广义表的方式。图 1（A）用广义表表示为：

(A , ( B ( E ( K , L ) , F ) , C ( G ) , D ( H ( M ) , I , J ) ) )

### 总结

树型存储结构类似于家族的族谱，各个结点之间也同样可能具有父子、兄弟、表兄弟的关系。本节中，要重点理解树的根结点和子树的定义，同时要会计算树中各个结点的度和层次，以及树的深度。

## 二叉树

前序遍历

前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。

请看下面的例子：

![Slide199](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\Slide199.png)

中序遍历

中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。

让我们一起来看树的中序遍历：

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\Slide22.png)

通常来说，对于二叉搜索树，我们可以通过中序遍历得到一个递增的有序序列。 我们将在另一张卡片（数据结构介绍 – 二叉搜索树）中再次提及。

后序遍历
后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。

我们一起来看后序遍历的动画演示：

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\Slide119.png)

值得注意的是，当你删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身。

另外，后序在数学表达中被广泛使用。 编写程序来解析后缀表示法更为容易。 这里是一个例子：

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\mathematical_expression.png)


您可以使用中序遍历轻松找出原始表达式。 但是程序处理这个表达式时并不容易，因为你必须检查操作的优先级。如果你想对这棵树进行后序遍历，使用栈来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中。



### 使用递归解决树问题

在前面的章节中，我们已经介绍了如何利用递归求解树的遍历。 递归是解决树的相关问题最有效和最常用的方法之一。

我们知道，树可以以递归的方式定义为一个节点（根节点），它包括一个值和一个指向其他节点指针的列表。 递归是树的特性之一。 因此，许多树问题可以通过递归的方式来解决。 对于每个递归层级，我们只能关注单个节点内的问题，并通过递归调用函数来解决其子节点问题。

通常，我们可以通过 “自顶向下” 或 “自底向上” 的递归来解决树问题。

“自顶向下” 的解决方案
“自顶向下” 意味着在每个递归层级，我们将首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点。 所以 “自顶向下” 的解决方案可以被认为是一种前序遍历。 具体来说，递归函数 top_down(root, params) 的原理是这样的：

```python
1. return specific value for null node
2. update the answer if needed                      // answer <-- params
3. left_ans = top_down(root.left, left_params)		// left_params <-- root.val, params
4. right_ans = top_down(root.right, right_params)	// right_params <-- root.val, params
5. return the answer if needed                      // answer <-- left_ans, right_ans
```


例如，思考这样一个问题：给定一个二叉树，请寻找它的最大深度。

我们知道根节点的深度是1。 对于每个节点，如果我们知道某节点的深度，那我们将知道它子节点的深度。 因此，在调用递归函数的时候，将节点的深度传递为一个参数，那么所有的节点都知道它们自身的深度。 而对于叶节点，我们可以通过更新深度从而获取最终答案。 这里是递归函数 maximum_depth(root, depth) 的伪代码：

```python
1. return if root is null
2. if root is a leaf node:
3. answer = max(answer, depth)         // update the answer if needed
4. maximum_depth(root.left, depth + 1)      // call the function recursively for left child
5. maximum_depth(root.right, depth + 1)		// call the function recursively for right child
```


以下的例子可以帮助你理解它是如何工作的：

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\Slide12.png)

```java
private int answer;		// don't forget to initialize answer before call maximum_depth
private void maximum_depth(TreeNode root, int depth) {
    if (root == null) {
        return;
    }
    if (root.left == null && root.right == null) {
        answer = Math.max(answer, depth);
    }
    maximum_depth(root.left, depth + 1);
    maximum_depth(root.right, depth + 1);
}
```



“自底向上” 的解决方案
“自底向上” 是另一种递归方法。 在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。 这个过程可以看作是后序遍历的一种。 通常， “自底向上” 的递归函数 bottom_up(root) 为如下所示：

>1. return specific value for null node
>2. left_ans = bottom_up(root.left)			// call function recursively for left child
>3. right_ans = bottom_up(root.right)		// call function recursively for right child
>4. return answers                           // answer <-- left_ans, right_ans, root.val

让我们继续讨论前面关于树的最大深度的问题，但是使用不同的思维方式：对于树的单个节点，以节点自身为根的子树的最大深度x是多少？

如果我们知道一个根节点，以其左子节点为根的最大深度为l和以其右子节点为根的最大深度为r，我们是否可以回答前面的问题？ 当然可以，我们可以选择它们之间的最大值，再加上1来获得根节点所在的子树的最大深度。 那就是 x = max（l，r）+ 1。

这意味着对于每一个节点来说，我们都可以在解决它子节点的问题之后得到答案。 因此，我们可以使用“自底向上“的方法。下面是递归函数 maximum_depth(root) 的伪代码：

>1. return 0 if root is null                 // return 0 for null node
>2. left_depth = maximum_depth(root.left)
>3. right_depth = maximum_depth(root.right)
>4. return max(left_depth, right_depth) + 1	// return depth of the subtree rooted at root


1. 以下的例子可以帮助你理解它是如何工作的：

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\Slide25.png)

```java
public int maximum_depth(TreeNode root) {
	if (root == null) {
		return 0;                                   // return 0 for null node
	}
	int left_depth = maximum_depth(root.left);
	int right_depth = maximum_depth(root.right);
	return Math.max(left_depth, right_depth) + 1;	// return depth of the subtree rooted at root
}
```

#### 总结

了解递归并利用递归解决问题并不容易。当遇到树问题时，请先思考一下两个问题：

1,你能确定一些参数，从该节点自身解决出发寻找答案吗？
2,你可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数吗？
如果答案都是肯定的，那么请尝试使用 “自顶向下” 的递归来解决此问题。

或者你可以这样思考：对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 如果答案是肯定的，那么 “自底向上” 的递归可能是一个不错的解决方法。

在接下来的章节中，我们将提供几个经典例题，以帮助你更好地理解树的结构和递归。

### N叉树

之前，我们更多关注于二叉树。本 LeetBook 将会把你对二叉树的认知延伸到 N 叉树（N-ary Tree） 。

完成后，你将能够：

>1. 理解 N 叉树的定义。
>2. 了解 N 叉树不同的遍历方法。
>3. 对于解决 N 叉树类型问题有基本的概念。

#### 遍历

在进行本章的学习之前，让我们先介绍一下 N 叉树的定义。

二叉树是一棵以根节点开始，每个节点含有不超过 2 个子节点的树。让我们将这个定义扩展到 N 叉树 。 一棵以根节点开始，每个节点不超过 N 个子节点的树，称为 N叉树 。

以下是三叉树的一个例子：

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\nary_tree_example1.png)

`前缀树` ，又称 `字典树（Trie）`， 就是一个常用的 N 叉树。

并且二叉树是 N 叉树的一种特殊表示形式。在接下来的章节中，我们将把你所掌握的与二叉树相关的知识全部拓展到 N 叉树中。

#### N 叉树的遍历

树的遍历

------

一棵二叉树可以按照前序、中序、后序或者层序来进行遍历。在这些遍历方法中，前序遍历、后序遍历和层序遍历同样可以运用到 N 叉树中。

>回顾 - 二叉树的遍历
>
>1,前序遍历 - 首先访问根节点，然后遍历左子树，最后遍历右子树；
>2,中序遍历 - 首先遍历左子树，然后访问根节点，最后遍历右子树；
>3,后序遍历 - 首先遍历左子树，然后遍历右子树，最后访问根节点；
>4,层序遍历 - 按照从左到右的顺序，逐层遍历各个节点。

请注意，N 叉树的中序遍历没有标准定义，中序遍历只有在二叉树中有明确的定义。尽管我们可以通过几种不同的方法来定义 N 叉树的中序遍历，但是这些描述都不是特别贴切，并且在实践中也不常用到，所以我们暂且跳过 N 叉树中序遍历的部分。

把上述关于二叉树遍历转换为 N 叉树遍历，我们只需把如下表述:

>遍历左子树... 遍历右子树... 

变为:

>对于每个子节点:
>   通过递归地调用遍历函数来遍历以该子节点为根的子树

我们假设 for 循环将会按照各个节点在数据结构中的顺序进行遍历：通常按照从左到右的顺序，如下所示。

##### N 叉树遍历示例

我们用如图所示的三叉树来举例说明:

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\nary_tree_example1.png)

1. ##### 前序遍历（根左右）

  在 N 叉树中，前序遍历指先访问根节点，然后逐个遍历以其子节点为根的子树。
  例如，上述三叉树的前序遍历是：A->B->C->E->F->D->G.

2. ##### 后序遍历（左右根）

  在 N 叉树中，后序遍历指前先逐个遍历以根节点的子节点为根的子树，最后访问根节点。
  例如，上述三叉树的后序遍历是：B->E->F->C->G->D->A.

3. ##### 层序遍历

  N 叉树的层序遍历与二叉树的一致。通常，当我们在树中进行广度优先搜索时，我们将按层序的顺序进行遍历。
  例如，上述三叉树的层序遍历是：A->B->C->D->E->F->G.

  ##### N 叉树的前序遍历

  给定一个 N 叉树，返回其节点值的前序遍历。

  例如，给定一个 3叉树 :

   ![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\narytreeexample.png)

  返回其前序遍历: [1,3,5,6,2,4]。




##### N 叉树的后序遍历

给定一个 N 叉树，返回其节点值的*后序遍历*。

例如，给定一个 `3叉树` :

 ![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\narytreeexample1.png)

返回其后序遍历: `[5,6,3,2,4,1]`.

##### N 叉树的层序遍历

给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

##### N 叉树的经典递归解法

经典递归法
我们在之前的章节中讲过如何运用递归法解决二叉树问题。在这篇文章中，我们着重介绍如何将这个思想引入到 N 叉树中。

在阅读以下内容之前，请确保你已阅读过 运用递归解决树的问题 这篇文章。

1. "自顶向下"的解决方案

"自顶向下"意味着在每个递归层次上，我们首先访问节点以获得一些值，然后在调用递归函数时，将这些值传给其子节点。

一个典型的 "自顶向下" 函数 top_down(root, params) 的工作原理如下：

>1. 对于 null 节点返回一个特定值
>
>2. 如果有需要，对当前答案 answer 进行更新                         // answer <-- params
>
>3. for each child node root.children[k]:
>
>   ​		ans[k] = top_down(root.children[k], new_params[k])  // new_params <-- root.val, params
>
>4. 如果有需要，返回答案 answer                                 // answer <-- all ans[k]
>
>5. "自底向上"的解决方案

"自底向上" 意味着在每个递归层次上，我们首先为每个子节点递归地调用函数，然后根据返回值和根节点本身的值给出相应结果。

一个典型的 "自底向上" 函数 bottom_up(root) 的工作原理如下：

>1.对于 null 节点返回一个特定值
>2.for each child node root.children[k]:
>
>​		ans[k] = bottom_up(root.children[k]) // 为每个子节点递归地调用函数
>
>4.返回答案 answer                          // answer <- root.val, all ans[k]

### 二叉搜索树

二叉搜索树是二叉树的一种特殊形式。 二叉搜索树具有以下性质：每个节点中的值必须大于（或等于）其左侧子树中的任何值，但小于（或等于）其右侧子树中的任何值。

我们将在本 LeetBook 中更详细地介绍二叉搜索树的定义，并提供一些与二叉搜索树相关的习题。

完成后，你将：

> 1,理解二叉搜索树的特性
> 2,熟悉在二叉搜索树中的基本操作
> 3,理解高度平衡二叉搜索树的概念

#### 二叉搜索树的定义

`二叉搜索树`（BST）是二叉树的一种特殊表示形式，它满足如下特性：

每个节点中的值必须大于（或等于）存储在其左侧子树中的任何值。
每个节点中的值必须小于（或等于）存储在其右子树中的任何值。


下面是一个二叉搜索树的例子：

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\bst_example-a1.png)

这篇文章之后，我们提供了一个习题来让你验证一个树是否是二叉搜索树。 你可以运用我们上述提到的性质来判断。 前一章介绍的递归思想也可能会对你解决这个问题有所帮助。

像普通的二叉树一样，我们可以按照前序、中序和后序来遍历一个二叉搜索树。 但是值得注意的是，对于二叉搜索树，我们可以通过中序遍历得到一个递增的有序序列。因此，中序遍历是二叉搜索树中最常用的遍历方法。

在本章习题中，我们也添加了让你求解二叉搜索树的中序后继节点（in-order successor）的题目。显然，你可以通过中序遍历来找到二叉搜索树的中序后继节点。 你也可以尝试运用二叉搜索树的特性，去寻求更好的解决方案。

#### 验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

> 1,节点的左子树只包含小于当前节点的数。
> 2,节点的右子树只包含大于当前节点的数。
> 3,所有左子树和右子树自身必须也是二叉搜索树。

#### 二叉搜索树迭代器

实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。

调用 `next()` 将返回二叉搜索树中的下一个最小的数。

#### 在二叉搜索树中实现搜索操作 - 介绍

二叉搜索树主要支持三个操作：搜索、插入和删除。 在本章中，我们将讨论如何在二叉搜索树中搜索特定的值。

根据BST的特性，对于每个节点：

> 1,如果目标值等于节点的值，则返回节点；
> 2,如果目标值小于节点的值，则继续在左子树中搜索；
> 3,如果目标值大于节点的值，则继续在右子树中搜索。


我们一起来看一个例子：我们在上面的二叉搜索树中搜索目标值为 4 的节点。

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\bst_search-a1.png)



#### 二叉搜索树中的搜索

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

#### 在二叉搜索树中实现插入操作 - 介绍


二叉搜索树中的另一个常见操作是插入一个新节点。有许多不同的方法去插入新节点，这篇文章中，我们只讨论一种使整体操作变化最小的经典方法。 它的主要思想是为目标节点找出合适的叶节点位置，然后将该节点作为叶节点插入。 因此，搜索将成为插入的起始。

与搜索操作类似，对于每个节点，我们将：

> 1,根据节点值与目标节点值的关系，搜索左子树或右子树；
> 2,重复步骤 1 直到到达外部节点；
> 3,根据节点的值与目标节点的值的关系，将新节点添加为其左侧或右侧的子节点。

这样，我们就可以添加一个新的节点并依旧维持二叉搜索树的性质。

我们来看一个例子：



#### 二叉搜索树中的插入操作

给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。

注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即

>1,给定的树上的节点数介于 0 和 10^4 之间
>2,每个节点都有一个唯一整数值，取值范围从 0 到 10^8
>3,-10^8 <= val <= 10^8
>4,新值和原始二叉搜索树中的任意节点值都不同

#### 在二叉搜索树中实现删除操作 - 介绍

删除要比我们前面提到过的两种操作复杂许多。有许多不同的删除节点的方法，这篇文章中，我们只讨论一种使整体操作`变化最小`的方法。我们的方案是用一个合适的子节点来替换要删除的目标节点。根据其子节点的个数，我们需考虑以下三种情况：

> 1,如果目标节点没有子节点，我们可以直接移除该目标节点。
>
> 2,如果目标节只有一个子节点，我们可以用其子节点作为替换。
>
> 3,如果目标节点有两个子节点，我们需要用其中序后继节点或者前驱节点来替换，再删除该目标节点。

我们来看下面这几个例子，以帮助你理解删除操作的中心思想：

**例 1：目标节点没有子节点**

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\bst_deletion_case_1.png)

**例 2：目标节只有一个子节点**

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\bst_deletion_case_2.png)

**例 3：目标节点有两个子节点**

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\bst_deletion_case_3.png)

通过理解以上的示例，你应该可以独立实现删除操作了。

#### 删除二叉搜索树中的节点

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

> 首先找到需要删除的节点；
> 如果找到了，删除它。

说明： 要求算法时间复杂度为 O(h)，h 为树的高度。



### 前缀树

`前缀树` ，又称 `字典树` ，是` N 叉树` 的特殊形式。

我们将深入讨论前缀树的实现方法以及如何将这个数据结构应用到实际问题中。完成后，你将能够：

>1. 理解前缀树的 `基本概念` ；
>2. 掌握前缀树中的 `插入` 和 `搜索操作` ；
>3. 了解前缀树如何帮助解决 `实际应用问题` ；
>4. 运用前缀树解题。

#### 前缀树简介

本章主要向大家解答两个基本问题：

- 什么是前缀树？
- 如何用代码表示这个数据结构？

如果你还不了解前缀树，阅读此章节会对你有所帮助。

##### 什么是前缀树?

`前缀树` 是` N叉树 `的一种特殊形式。通常来说，一个前缀树是用来 `存储字符串` 的。前缀树的每一个节点代表一个 `字符串（前缀）`。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的 `原始字符串 `，以及 `通往该子节点路径上所有的字符 `组成的。

下面是前缀树的一个例子：

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\screen-shot-2018-01-31-at-163403.png)

在上图示例中，我们在节点中标记的值是该节点对应表示的字符串。例如，我们从根节点开始，选择第二条路径 'b'，然后选择它的第一个子节点 'a'，接下来继续选择子节点 'd'，我们最终会到达叶节点 "bad"。节点的值是由从根节点开始，与其经过的路径中的字符按顺序形成的。

值得注意的是，根节点表示` 空字符串 `。

`前缀树`的一个重要的特性是，节点所有的后代都与该节点相关的字符串有着共同的前缀。这就是 `前缀树 `名称的由来。

我们再来看这个例子。例如，以节点 "b" 为根的子树中的节点表示的字符串，都具有共同的前缀 "b"。反之亦然，具有公共前缀 "b" 的字符串，全部位于以 "b" 为根的子树中，并且具有不同前缀的字符串来自不同的分支。

前缀树有着广泛的应用，例如自动补全，拼写检查等等。我们将在后面的章节中介绍实际应用场景。

##### 如何表示一个前缀树？

在前面的文章中，我们介绍了前缀树的概念。在这篇文章中，我们将讨论如何用代码表示这个数据结构。

在阅读一下内容前，请简要回顾 `N 叉树`的节点结构。

前缀树的特别之处在于字符和子节点之间的对应关系。有许多不同的表示前缀树节点的方法，这里我们只介绍其中的两种方法。

######  方法一 数组

第一种方法是用 `数组 `存储子节点。

例如，如果我们只存储含有字母 a 到 z 的字符串，我们可以在每个节点中声明一个大小为 26 的数组来存储其子节点。对于特定字符 c ，我们可以使用 c - 'a' 作为索引来查找数组中相应的子节点。

```java
class TrieNode {
    // change this value to adapt to different cases
    public static final int N = 26;
    public TrieNode[] children = new TrieNode[N];  
    // you might need some extra values according to different cases
};
/** Usage:
 *  Initialization: TrieNode root = new TrieNode();
 *  Return a specific child node with char c: root.children[c - 'a']
 */
```

访问子节点十分 快捷 。访问一个特定的子节点比较 容易 ，因为在大多数情况下，我们很容易将一个字符转换为索引。但并非所有的子节点都需要这样的操作，所以这可能会导致`空间`的浪费 。

###### 方法二 Map

第二种方法是使用` Hashmap `来存储子节点。

我们可以在每个节点中声明一个 `Hashmap` 。`Hashmap `的键是字符，值是相对应的子节点。

```java
class TrieNode {
    public Map<Character, TrieNode> children = new HashMap<>();  
    // you might need some extra values according to different cases
    //根据不同的情况，您可能需要一些额外的值
};
/**Usage:使用：
 *Initialization: TrieNode root = new TrieNode();
 *Return a specific child node with char c: root.children.get(c)
 *初始化:TrieNode root = new TrieNode();
 *返回一个特定的子节点，使用char c:root.children.get(c)
 */
```

通过相应的字符来访问特定的子节点 更为容易 。但它可能比使用数组 稍慢一些 。但是，由于我们只存储我们需要的子节点，因此 节省了空间 。这个方法也更加 灵活 ，因为我们不受到固定长度和固定范围的限制。

##### 补充

我们已经提到过如何表示前缀树中的子节点。除此之外，我们也需要用到一些其他的值。

例如，我们知道，前缀树的每个节点表示一个字符串，但并不是所有由前缀树表示的字符串都是有意义的。如果我们只想在前缀树中存储单词，那么我们可能需要在每个节点中声明一个布尔值（Boolean）作为标志，来表明该节点所表示的字符串是否为一个单词。

### 前缀树中的插入操作

我们已经在另一本 LeetBook 中讨论了 (如何在二叉搜索树中实现插入操作)。

提问：你还记得如何在二叉搜索树中插入一个新的节点吗？

当我们在二叉搜索树中插入目标值时，在每个节点中，我们都需要根据 节点值 和 目标值 之间的关系，来确定目标值需要去往哪个子节点。同样地，当我们向前缀树中插入一个目标值时，我们也需要根据插入的 目标值 来决定我们的路径。

更具体地说，如果我们在前缀树中插入一个字符串 S，我们要从根节点开始。 我们将根据 S[0]（S中的第一个字符），选择一个子节点或添加一个新的子节点。然后到达第二个节点，并根据 S[1] 做出选择。 再到第三个节点，以此类推。 最后，我们依次遍历 S 中的所有字符并到达末尾。 末端节点将是表示字符串 S 的节点。

下面是一个例子：

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\Slide5.png)

我们来用伪代码总结一下以上策略：

```python
1. Initialize: cur = root
2. for each char c in target string S:
3. 		if cur does not have a child c:
4.			cur.children[c] = new Trie node
5.		cur = cur.children[c]
6. cur is the node which represents the string S
```

通常情况情况下，你需要自己构建前缀树。构建前缀树实际上就是多次调用插入函数。但请记住在插入字符串之前要 `初始化根节点` 。

#### 搜索前缀

正如我们在前缀树的简介中提到的，所有节点的后代都与该节点相对应字符串的有着共同前缀。因此，很容易搜索以特定前缀开头的任何单词。

同样地，我们可以根据给定的前缀沿着树形结构搜索下去。一旦我们找不到我们想要的子节点，搜索就以失败终止。否则，搜索成功。为了更具体地解释搜索的过程，我们提供了下列示例：

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\Slide041.png)

![img](E:\oldF\learningDocument\git-workspace\PANDA-Walker\picture\Slide101.png)

我们来用伪代码总结一下以上策略：

```python
1. Initialize: cur = root
2. for each char c in target string S:
3. 		if cur does not have a child c:
4.			search fails
5.		cur = cur.children[c]
6. search successes
```

#### 搜索单词

你可能还想知道如何搜索特定的单词，而不是前缀。我们可以将这个词作为前缀，并同样按照上述同样的方法进行搜索。

1,如果搜索失败，那么意味着没有单词以目标单词开头，那么目标单词绝对不会存在于前缀树中。

2,如果搜索成功，我们需要检查目标单词是否是前缀树中单词的前缀，或者它本身就是一个单词。为了进一步解决这个问题，你可能需要稍对节点的结构做出修改。

>提示：往每个节点中加入布尔值可能会有效地帮助你解决这个问题

实现 Trie (前缀树)
实现一个 Trie (`前缀树`)，包含` insert`, `search`, 和 `startsWith` 这三个操作。

示例:

```java
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 true
trie.search("app");     // 返回 false
trie.startsWith("app"); // 返回 true
trie.insert("app");   
trie.search("app");     // 返回 true
```



> 说明:
>
> 你可以假设所有的输入都是由小写字母 a-z 构成的。
> 保证所有输入均为非空字符串。

##### Implement Trie - Solution

Problem: Implement a trie with insert, search, and startsWith methods.

解决这一问题的关键是设计Trie节点结构。为了知道节点所表示的字符串是否是一个单词，我们需要额外的布尔标记。

当插入一个新单词时，我们将该单词的结束节点中的标志设置为true。当我们实现startsWith方法时，如果成功找到路径则返回true。但是，当我们实现搜索方法时，只有在成功找到路径并且结束节点的标志为true时才返回true。

```java
class Trie {
    class TrieNode {
        public boolean isWord; 
        public Map<Character, TrieNode> childrenMap = new HashMap<>();
    }
    
    private TrieNode root; 

    /** Initialize your data structure here. */
    public Trie() {
        root = new TrieNode();
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        TrieNode cur = root;
        for(int i = 0; i < word.length(); i++){
            char c = word.charAt(i);
            if(cur.childrenMap.get(c) == null){
                // insert a new node if the path does not exist
                cur.childrenMap.put(c, new TrieNode());
            }
            cur = cur.childrenMap.get(c); 
        }
        cur.isWord = true;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        TrieNode cur = root;
        for(int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            if(cur.childrenMap.get(c) == null) {
                return false;
            }
            cur = cur.childrenMap.get(c);
        }
        return cur.isWord;
    }
   
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        TrieNode cur = root;
        for(int i = 0;i < prefix.length(); i++){
            char c = prefix.charAt(i);
            if(cur.childrenMap.get(c) == null) {
                return false;
            }
            cur = cur.childrenMap.get(c);
        }
        return true;
    }
}
```



Complexity Analysis

我们来讨论一下这个算法的复杂性。

如果单词的最长长度是N，那么重试的高度就是N + 1。因此，所有insert、search和startsWith方法的时间复杂度均为O(N)。

空间复杂性如何?

如果我们总共要插入M个单词，单词的长度最多为N，那么在最坏的情况下，最多将有M*N个节点(任意两个单词没有共同的前缀)。

让我们假设有最多K个不同的字符(在这个问题中K等于26，但在不同的情况下可能不同)。因此，每个节点将保持一个map，其大小不超过K。

> 因此，空间复杂度为O(M *N *K)。

虽然看起来确实是一种空间消耗，但是，实际的空间复杂度比我们估计的要小得多，特别是当单词分布比较密集的时候。

你也可以通过数组来实现它，这将获得稍好的时间性能，但稍低的空间性能。

###### 与哈希表比较

您可能想知道为什么不使用哈希表来存储字符串。让我们简单比较一下这两种数据结构。我们假设有N个键，一个键的最大长度是M。

时间复杂度

在哈希表中搜索的时间复杂度通常是O(1)，但如果有太多的碰撞，我们使用高度平衡的BST解决碰撞，在最坏的时间将是O(logN)。

在trie中搜索的时间复杂度为O(M)。

哈希表在大多数情况下获胜。

###### 空间复杂度

哈希表的空间复杂度是O(M * N)，如果你想让哈希表具有与Trie相同的功能，你可能需要存储几个键的副本。例如，你可能想要存储“a”，“ap”，“app”，“appl”和“apple”为关键词“apple”，以便通过前缀进行搜索。在这种情况下，空间复杂性可能会更大

如上所估计的，Trie的空间复杂度为O(M * N)。但实际上要比估计的小得多，因为在实际情况中会有很多单词有类似的前缀。

在大多数情况下，trie会赢。

